# 11. 컬렉션 프레임웍
컬렉션은 다수의 데이터, 즉 데이터 그룹을 나타내고, 프레임웍은 표준화된 프로그래밍 방식을 의미한다. 컬렉션 프레임웍은 다수의 데이터를 다루는 데 필요한 다양하고 풍부한 클래스들을 제공하고 있고, 객체지향적 설계를 통해 표준화 되어 있어 사용법을 익히기에도 편리하고 재사용성이 높은 코드를 작성할 수 있다는 장점을 갖고 있다.

## 1.1 컬렉션 프레임웍의 핵심 인터페이스
컬렉션 데이터 그룹을 크게 3가지 타입으로 정의하고 3개의 인터페이스를 정의했다. 인터페이스 List, Set의 공통 부분은 다시 뽑아 새로운 인터페이스인 Collection을 추가로 정의하였다.

List와 Set을 구현한 컬렉션 클래스들은 공통점이 많아서 공통된 부분을 Collection 인터페이스를 정의할 수 있었지만, Map 인터페이스는 전혀 다른 형태로 컬렉션을 다루기 때문에 같은 상속 계층도에 포함되지 못했다.

[인터페이스의 특징]
* List : 순서가 있고, 데이터의 중복을 허용한다.
* Set : 순서를 유지하지 않고, 데이터의 중복을 허용하지 않는다.
* Map : 키와 값의 쌍으로 이루어진 데이터 집합, 순서를 유지하지 않고, 키는 중복을 허용하며 값은 중복을 허용하지 않는다.

__Collection 인터페이스__

<img src="/2회독/img/Collection.jpeg" width="700px">

Collection 인터페이스는 컬렉션 클래스에 저장된 데이터를 읽고, 추가하고, 삭제하는 등 컬렉션을 다루는데 가장 기본적인 메서드들을 정의하고 있다.

__List 인터페이스__

<img src="/2회독/img/List.jpeg" width="700px">

__Set 인터페이스__

__Map 인터페이스__

<img src="/2회독/img/Map.jpeg" width="700px">

Map 인터페이스에서는 값은 중복을 허용하기 때문에 values()에서는 Collection 타입으로 반환하고, 키는 중복을 허용하지 않기 때문에 keySet()은 Set 타입으로 반환한다.

__Map.Entry 인터페이스__ Map 인터페이스의 내부 인터페이스이다.  Map에 저장되는 key-value쌍을 다루기 위해 내부적으로 Entry 인터페이스를 정의해 놓았다. Map 인터페이스를 구현하는 클래스에서는 Map.Entry 인터페이스도 함께 구현해야 한다.

## 1.2 ArrayList
ArrayList는 List 인터페이스를 구현하기 때문에 `데이터의 저장 순서가 유지되고 중복을 허용한다`는 특징을 갖는다. Vector를 개선한 버전으로 구현 원리와 기능적인 측면에서 두 가지는 동일하나 Vector는 기존 코드와의 호환성 때문에 남겨놓은 것이므로 Vector 보다는 ArrayList를 사용하자

ArrayList는 Object 배열을 이용해서 데이터를 순차적으로 저장한다. 그리고 배열에 더이상 저장할 공간이 없으면 보다 큰 새로운 배열을 생성하여 기존의 배열에 저장된 내용을 새로운 배열로 복사한 다음 저장된다.

```java
//list1이 list2의 모든 요소를 포함하고 있는가
list1.containAll(list2);

//list1에서 list2와 겹치는 부분만 남기고 나머지 삭제
list1.retainAll(list2);

//Collections 클래스를 이용하여 list 정렬
Collections.sort(list);
```

list의 요소 중 중간 요소부터 삭제하는 경우 앞에서 부터 삭제하면 빈 공간을 채우기 위해 나머지 요소들이 자리 이동을 하기 때문에 뒤에서부터 삭제하도록 하자

## 1.3 LinkedList
배열의 단점으로 1.크기를 변경할 수 없다. 2.비순차적인 데이터의 추가 또는 삭제에 시간이 많이 걸린다. 이러한 배열의 단점을 보완하기 위해 Linked List라는 자료구조가 고안되었다. 배열은 모든 데이터가 연속적으로 존재하지만 Linked List는 불연속적으로 존재하는 데이터를 서로 연결한 형태로 구성되어 있다.

Linked List에서 데이터 삭제는 간단하다. 삭제하고자 하는 요소의 이전 요소가 삭제하고자 하는 요소의 다음 요소를 참조하도록 변경하기만 하면 된다. 배열처럼 데이터를 이동하기 위해 복사하는 과정이 없기 때문에 처리속도가 매우 빠르다.

새로운 요소를 추가할 때는 새로운 요소를 생성한 다음 추가하고자 하는 위치의 이전 요소의 참조를 새로운 요소에 대한 참조로 변경해주고, 새로운 요소가 그 다음 요소를 참조하도록 변경하기만 하면 되므로 속도가 빠르다.

Linked List는 이동방향이 단방향이기 때문에 다음 요소에 대한 접근은 쉽지만 이전 요소에 대한 접근은 어렵다. 이 점을 보안한 것이 doublylinked list 이다. 이는 참조 변수를 하나 더 추가하여 다음 요소의 참조뿐 아니라 이전 요소에 대한 참조가 가능하도록 했다.

또 더블 링크드 리스트의 접근성을 향상시킨 것이 더블 써큘러 링크드 리스트형 연결리스트로 더블 링크드 리스트의 첫 번째 요소와 마지막 요소를 서로 연결시킨 것이다.

1. `순차적`으로 추가/삭제하는 경우에는 ArrayList가 LinkedList보다 빠르다.
2. 중간 데이터를 추가/삭제하는 경우에는 LinkedList가 ArrayList보다 빠르다.

다루고자 하는 데이터의 개수가 변하지 않는 경우라면 ArrayList가 좋고, 데이터 개수의 변경이 잦다면 LinkedList를 사용하는 것이 더 나은 선택이 될 것이다.

## 1.4 Stack과 Queue
Stack은 마지막에 저장한 데이터를 가장 먼저 꺼내게 되는 LIFO 구조로 되어 있고, Queue는 처음에 저장한 데이터를 가장 먼저 꺼내게 되는 FIFO 구조로 되어 있다.

Stack에 0, 1, 2의 순서로 데이터를 넣었다면 꺼낼 때는 2, 1, 0의 순서로 꺼내게 된다. 반대로 Queue는 0, 1, 2의 순서로 데이터를 넣었다면 꺼낼때ㄷ 0, 1, 2 순서로 꺼내게 된다.

Stack에는 ArrayList와 같은 배열기반의 컬렉션 클래스가 적합하지만 Queue는 데이터를 꺼낼 때 항상 첫 번째 저장된 데이터를 삭제하므로 ArrayList 보다 LinkedList로 구현하는 것이 더 적합하다.

```java
public static void main(String[] args) {
	Stack stack = new Stack();
        Queue queue = new LinkedList();

        stack.push("0");
        stack.push("1");
        stack.push("2");

        queue.offer("0");
        queue.offer("1");
        queue.offer("2");

        System.out.println("=== Stack ===");
        while (!stack.empty()) {    //empty : stack이 비었는지 알려준다.
            System.out.println(stack.pop());
        }
        System.out.println("=== Queue ===");
        while (!queue.isEmpty()) {
            System.out.println(queue.poll());
        }
}
```
자바에서는 스택을 Stack 클래스로 구현하여 제공하고 있으나 큐는 Queue 인터페이스로 정의만 해놓고 별도의 클래스를 제공하고 있지 않다.

```java
class MyStack extends Vector {
	public Object push(Object item) {
		addElement(item);
		return item;
	}

	public Object pop() {
		Object obj = peek();  //statck에 저장된 마지막 요소를 읽어온다.
		removeElementAt(size() - 1);
		return obj;
	}

	public Object peek() {
		int len = size();

		if(len == 0) throw new EmptyStackException();

		return elementAt(len-1);	//마지막 요소를 반환한다.
	}

	public boolean empty() {
		return size() == 0;
	}

	public int search(Object o) {
		int i = lastIndexOf(o);		//끝에서부터 객체를 찾는다


		//객체를 찾은 경우 
		if(i >= 0) {
			return size() - i;
		}
		return -1;
	}
}

```
__스택과 큐의 활용__

* 스택 : 수식 계산, 수식괄호 검사, 워드의 undo/redo, 웹 브라우저의 뒤로/앞으로
* 큐 : 최근 사용문서, 인쇄작업 대기목록, 버퍼

```java
//입력한 수식의 괄호가 올바른지 체크
public static void main(String[] args) {
	if(args.length != 1)
		System.exit(0);

	Stack st = new Stack();
	String expression = args[0];

	System.out.println("expression :" + expression);

	try {
		for(int i = 0; i < expression.length(); i++) {
			char ch = expression.charAt(i);

			if(ch == '(') {
				st.push(ch+"");
			}else if(ch ==')') {
				st.pop();
			}
		}

		if(st.isEmpty()) {
			System.out.println("괄호가 일치합니다.");
		}else {
			System.out.println("괄호가 일치하지 않습니다.")
		}
	} catch (EmptyStackException e) {
		System.out.println("괄호가 일치하지 않습니다.")
	}
}
```
```java
//Queue 예제
static Queue q = new LinkedList();
static final int MAX_SIZE = 5; //Queue 최대 5개까지만 저장

public static void main(String[] args) {
	System.out.println("help를 입력하면 도움말을 볼 수 있습니다.");

	while(true) {
		System.out.println(">>");

		try{
			Scanner s = new Scanner(System.in);
			String input = s.nextLine().trim(); //공백제거

			if("".equals(input)) continue;

			if(input.equalsIgnoreCase("q")) {
				System.exit(0);
			}else if(input.equalsIgnoreCase("help")) {
				System.out.println("help - 도움말을 보여줍니다.");
				System.out.println("q 또는 Q - 프로그램을 종료합니다.");
				System.out.println("help - 도움말을 보여줍니다.");
			}else if(input.equalsIgnoreCase("history")) {
				int i = 0;
				save(input); //queue에 저장

				LinkedList tmp = (LinkedList)q;
				ListIterator it = tmp.listIterator();

				while(it.hasNext()) System.out.println(++i+"."+it.next());
			}else {
				save(input);
				System.out.println(input);
			}
		}catch(Exception e) {
			System.out.println("입력 오류입니다.");
		}
	}
}

public static void save(String input) {
	if(!"".equals(input)) q.offer(input);
	if(q.size() > MAX_SIZE) q.remove();
}
```

__PriorityQueue__

Queue 인터페이스의 구현체 중의 하나로 저장한 순서에 관계없이 우선순위가 높은 것부터 꺼내게 된다는 특징이 있다. 그리고 null은 저장할 수 없다. PriorityQueue는 저장공간으로 배열을 사용하며 각 요소를 heap이라는 자료구조의 형태로 저장한다. 

__Deque__

Deque는 양쪽 끝에 추가/삭제가 가능하다. 