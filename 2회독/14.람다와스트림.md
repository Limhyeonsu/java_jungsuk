# 14. 람다와 스트림
## 1. 람다식
JDK 1.8 부터 추가된 람다식으로 인해 자바는 객체지향 언어에서 동시에 함수형 언어가 되었다.

### 1.1 람다식이란?
람다식은 메서드를 하나의 __식(expression)__ 으로 표현한 것이다. 메서드를 람다식으로 표현하면 메서드의 이름과 반환 값이 없어지므로 람다식을 `익명함수` 라고도 한다.

```java
//람다식
int[] arr = new int[5];
Arrays.setAll(arr, () -> (int) (Math.random() * 5) +1);

//람다식 -> 메서드
int method() {
	return (int)(Math.random() * 5) + 1;
}
```

모든 메서드는 클래스에 포함되어야 하므로 클래스도 새로 만들어야 하고, 객체도 생성해야만 메서드를 호출할 수 있다. 그러나 람다식은 이 모든 과정 없이 오직 람다식 자체만으로 메서드 역할을 대신할 수 있다. 또 람다식은 메서드의 매개변수로 전달되어지는 것이 가능하고, 메서드의 결과로 반환될 수도 있다. 즉 메서드를 변수처럼 다루는 것이 가능해진 것이다.

**메서드와 함수의 차이 : 수학의 함수와 개념이 유사하나 객체지향 개념에서 함수 대신 객체의 행위나 동작을 의미하는 메서드라는 용어를 사용한다.

### 1.2 람다식 작성하기
메서드에서 이름과 반환 타입을 제거하고 매개변수 선언부와 몸통 사이에 '->' 를 추가한다. `(매개변수 선언) -> { 실행 문장들 }`

```java
int max(int a, int b) {
	return a > b ? a : b;
}

//1. 반환 타입과 메서드 이름을 제거한다.
(int a, int b) -> {
	return a > b ? a : b;
}

//2. 매개변수의 타입은 추론이 가능한 경우 생략할 수 있다.
// 그리고 문장이 아닌 식이므로 끝에 ; 을 붙이지 않는다.
(a, b) -> return a > b ? a : b

//3. 매개변수가 하나인 경우 () 괄호를 생략할 수 있다. 단 타입이 있는 경우 생략 불가
a -> a *a
(int a) -> a * a

//4. {} 괄호 안에 문장이 하나일땐 생략 가능, {} 괄호 안에 문장이 return 문인 경우 괄호 생략가능

```

<img src="/2회독/img/메서드to람다식.jpeg" width="700px">

### 1.3 함수형 인터페이스
람다식은 익명 클래스의 객체와 동등하다. 참조변수가 있어야 객체의 메서드를 호출할 수 있는 것처럼 익명 객체의 주소를 임의의 변수에 저장하기 위해서는 타입이 필요하다. 이때 타입은 어떤 타입으로 해야할까?

```java
interface MyFunction {
	public abstract int max(int a, int b);
}

MyFunction f = new MyFunction() {
	public int max(int a, int b) {
		return a > b ? a: b;
	}
};

int big = f.max(5, 3);  //익명 객체의 메서드 호출

MyFunction f = (int a, int b) -> a > b ? a : b; //람다식으로 대체

```
위 예제에서 MyFunction 인터페이스를 구현한 익명 객체를 람다식으로 대체 가능한 이유는 람다식도 실제로는 익명 객체이고, 익명 객체의 메서드 max()와 람다식의 매개변수의 타입과 개수, 반환값이 일치하기 때문이다. 그래서 인터페이스를 통해 람다식을 다루기로 결정되었으며 __람다식을 다루기 위한 인터페이스를 함수형 인터페이스__ 라고 부르기로 했다.

```java
@FunctionalInterface
interface MyFunction {
	public abstract int max(int a, int b);
}
```
`함수형 인터페이스`에는 오직 `하나의 추상 메서드만 정의`되어 있어야 한다는 제약이 있다. 그래야 람다식과 인터페이스의 메서드가 1:1로 연결될 수 있다. 반면 ststic 메서드와 default 메서드의 개수에는 제약이 없다.

```java

@FunctionalInterface
interface MyFunction {
	void myMethod();
}

//1. 함수형 인터페이스 타입의 매개변수인 경우 

void aMethod(MyFunction f) {
	f.myMethod();
}

...

MyFunction f = System.out.println("MyMethod()");
aMethod(f);		//참조 변수를 매개변수로 지정

aMethod(() -> System.out.println("myMethod"));  //람다식을 매개변수로 지정


//2. 함수형 인터페이스 타입의 반환 타입인 경우
MyFunction myMethod() {
	MyFunction f = () -> {};
	return f;  //참조 변수를 반환 타입으로 지정
	// return () -> {};  람다식을 직접 반환
}
```

__람다식의 타입과 형변환 :__ 람다식은 함수형 인터페이스로 람다식을 참조할 수 있을 뿐, 람다식의 타입이 함수형 인터페이스의 타입과 일치하는 것은 아니다. `람다식은 익명 객체이고, 익명 객체는 타입이 없다.`

__외부 변수를 참조하는 람다식__

```java
@FunctionalInterface
interface MyFunction {
	void myMethod();
}

class Outer {
	int val = 10;	//Outer.this.val

	class Inner {
		int val = 20;	//this.val

		void method(int i) {
			int val = 30;
			i = 10;  //error
			MyFunction f = () -> {
				System.out.println("i = " + i);
				System.out.println("val = " + val);
				System.out.println("this.val = " + ++this.val);
				System.out.println("Outer.this.val = " + ++Outer.this.val);
				System.out.println("i = " + i);
			}
		}
	}
}
```
위 예는 람다식 내에서 외부에 선언된 변수에 접근하는 방법이다. `람다식 내에서 참조하는 지역변수는 final이 붙지 않았어도 상수로 간주`된다. 따라서 __람다식 내에서 지역변수를 참조하고 있으므로 람다식 내에서나 다른 어느곳에서도 이 변수들의 값을 변경하는 일은 허용되지 않는다.__

### 1.4 java.util.function 패키지
대부분의 메서드는 타입이 비슷하다. 매개변수가 없거나 한 개 또는 두 개, 반환 값은 없거나 한 개, 게다가 지네릭 메서드로 정의하면 매개변수나 반환 타입이 달라도 문제가 되지 않는다. 그래서 java.util.function 패키지에 일반적으로 자주 쓰이는 형식의 메서드를 함수형 인터페이스로 미리 정의해 놓았다. 그래야 메서드의 이름도 통일되고, 재사용성이나 유지보수 측면에서도 좋다.

| 함수형 인터페이스          |메서드|설명|
|--------------------|----|---|
| java.lang.Runnable |void run()|매개변수도 없고, 반환값도 없음|
| Supplier\<T>       |T get()|매개변수는 없고, 반환값만 있음|
| Consumer\<T>       |void accept(T t)|Supplier와 반대로 매개변수만 있고, 반환값이 없음|
| Function\<T, R>    |R apply(T t)|하나의 매개변수를 받아서 결과를 반환|
| Predicate\<T>      |boolean test(T t)|조건식을 표현하는데 사용됨|

매개변수와 반환값의 유무에 따라 4개의 함수형 인터페이스가 정의되어 있고, Function의 변형으로 Predicate가 있다. 이는 조건식을 함수로 표현하는데 사용된다.

```java
Predicate<String> isEmptyStr = s -> s.length() == 0;
String s = "";
if(isEmptyStr.test(s)) System.out.println("This is an empty String");
```

매개변수가 두 개인 함수형 인터페이스

|함수형 인터페이스|메서드|설명|
|------------|----|---|
|BiConsumer\<T, U>| void accept(T t, U u)|두개의 매개변수만 있고 반환값이 없음|
|BiPredicate\<T,U>|boolean test(T t, U u)|조건식을 표현하는 데 사용됨, 매개변수는 둘 반환값은 boolean|
|BiFunction\<T,U,R>|R apply(T t, U u)|두 개의 매개변수를 받아서 하나의 결과를 반환|

UnaryOperator와 BinaryOperator는 Function의 또 다른 변형으로 매개변수의 타입과 반환타입의 타입이 모두 일치한다.

```java
//컬렉션 프레임웍과 함수형 인터페이스
ArrayList<Integer> list = new ArrayList<>();
for(int i = 0; i < 10; i++) {
    list.add(i);
}

list.forEach(i -> System.out.print(i+",");
list.removeIf(x -> x%2==0 || x%3==0);
list.replaceAll(i -> i*10)

Map<String, String> map = new HashMap<>();
map.put("1","1");
map.put("2","2");
map.put("3","3");
map.put("4","4");

map.forEach((k,v) -> System.out.println("{"+k + ", " + v + "}"); 
```

```java
//함수형 인터페이스 사용예제
Supplier<Integer> s = () -> (int)(Math.random()*100) +1;
Consumer<Integer> c = i -> System.out.println(i);
Predicate<Integer> p = i -> i%2==0;
Function<Integer, Integer> f = i -> i/10*10;
```

기본형을 사용하는 함수형 인터페이스

|함수형 인터페이스|메서드|설명|
|------------|----|---|
|DoubleToIntFunction|int applyAsInt(double d)|AtoBFunciotn은 입력이 A타입 출력이 B타입|
|ToIntFunction\<T>|int applyAsInt(T value)|ToBFunction은 출력이 B타입, 입력은 지네릭|
|ObjIntConsumer\<T>|void accept(T t, U u)| ObjAFunction은 입력이 T, A타입이고 출력은 없다|

## 1.5 Function의 합성과 Predicate의 결합
### Function의 합성
수학에서 두 함수를 합성해서 하나의 새로운 함수를 만들어낼 수 있는 것처럼, 두 람다식을 합성해서 새로운 람다식을 만들 수 있다.  두 함수의 합성은 어느 함수를 먼저 적용하느냐에 따라 달라진다.
예) 함 f, g가 있을 때 f.andThen(g)는 함수 f를 먼저 적용하고, 그 다음에 함수 g를 적용한다. 그리고 f.compose(g)는 반대로 g를 먼저 적용하고 f를 적용한다.

```
//문자열 -> 숫자 변환하는 함수 f 와 숫자를 2진 문자열로 변환하는 함수 g
Function<String, Integer> f = (s) -> Integer.parseInt(s, 16);
Function<Integer, String> g = (i) -> Integer.toBinaryString(i);
Function<String, String> h = f.andThen(g);

결과 : "FF" -> "11111111"
```
```
Function<Integer, String> g = (i) -> Integer.toBinaryString(i);
Function<String, Integer> f = (s) -> Integer.parseInt(s, 16);
Function<Integer, Integer> h = f.compose(g);
결과 : 2 -> 16
```

identity()는 함수를 적용하기 이전과 이후가 동일한 항등 함수가 필요할 때 사용한다. 예) x -> x, 잘 사용되지 않음

### Predicate의 결합
```java
Predicate<Integer> p = i -> i < 100;
Predicate<Integer> q = i -> i < 200;
Predicate<Integer> r = i -> i % 2 == 0;
Predicate<Integer> notP = p.negate();  //i >= 100 (끝에 negate()를 붙이면 조건식 전체가 부정이 된다.)

Predicate<Integer> all = notP.and(q.or(r));		//i >= 100 && (i < 200 || i % 2 ==0)

//람다식으로도 가능
Predicate<Integer> all = notP.and(i -> i < 200).or(i -> i % 2 ==0);

```

static 메서드인 isEqual()은 두 대상을 비교하는 Predicate를 만들 때 사용한다.

```java
//str1과 str2가 같은지 비교한다.
boolean result = Predicate.isEqual(str1).test(str2);
```

## 1.6 메서드 참조
람다식을 더욱 간결하게 표현할 수 있는 방법이 있다. 람다식이 하나의 메서드만 호출하는 경우에 __메서드 참조__ 라는 방법으로 람다식을 간략히 할 수 있다.

```
//예) 문자열을 정수로 변환하는 람다식
Function<String, Integer> f = (String s) -> Integer.parseInt(s);

//메서드 참조
Function<String, Integer> f = Integer::parseInt;	//클래스이름::메서드이름

//참조변수 f의 타입만 봐도 람다식이 두 개의 String 타입으로 매개변수를 받는다는 것을 알 수 있으므로 람다식의 매개변수들은 없어도 된다.
BiFunction<String, String, Boolean> f = (s1, s2) -> s1.equals(s2);
BiFunction<String, String, Boolean> f = String::equals;
```

Boolean을 반환하는 equals라는 이름의 메서드는 다른 클래스에도 존재할 수 있기 때문에 equals 앞에 클래스 이름은 반드시 필요하다.

```
MyClass obj = new MyClass();
Function<String, Boolean> f = (x) -> obj.equals(x);

//이미 생성된 객체의 메서드를 람다식에서 사용한 경우 클래스 이름 대신 객체의 참조변수를 적어줘야 한다.
Function<String, Boolean> f2 = obj::equals;
```

|종류|람다|메서드 참조|
|----|----|---------|
|static 메서드 참조|(x) -> ClassName.method(x)|ClassName::method|
|인스턴스 메서드 참조|(obj, x) -> obj.method(x)|ClassName::method|
|특정 객체 인스턴스 메서드 참조|(x) -> obj.method(x)|obj::method|


### 생성자의 메서드 참조
```
Supplier<MyClass> s = () -> new MyClass();
Supplier<MyClass> s = MyClass::new;

Function<Integer, MyClass> f = (i) -> new MyClass(i);
Function<Integer, MyClass> f2 = MyClass::new;

BiFunction<Integer, String, MyClass> bf = (i, s) -> new MyClass(i, s);
BiFunction<Integer, String, MyClass> bf = MyClass::new;

Function<Integer, int[]> f = x -> new int[x];
Function<Integer, int[]> f2 = int[]::new;
```

## 2. 스트림
### 2.1 스트림이란?
각 컬렉션 클래스에는 같은 기능이 메서드들이 중복해서 정의되어 있다. 이러한 문제점들을 해결하기 위해서 만든 것이 스트림이다. 스트림은 데이터 소스를 추상화하고, 데이터를 다루는데 자주 사용되는 메서드들을 정의해 놓았다. 추상화 했다는 것은 데이터 소스가 무엇이던 간에 `같은 방식`으로 다룰 수 있게 되었다는 것과 `코드의 재사용성이 높아진다`는 것을 의미한다.

```java
String[] strArr = {"aaa", "ddd", "ccc"};
List<String> strList = Arrays.asList(strArr);

Stream<String> strStream1 = strList.stream();
Stream<String> strStream2 = Arrays.stream(strArr);

strStream1.sorted().forEach(System.out::println);
strStream2.sorted().forEach(System.out::println);
```

위 예제에서 두 스트림의 데이터 소스는 서로 다르지만, 정렬하고 출력하는 방법은 완전히 동일하다.

1. 스트림은 데이터 소스를 변경하지 않는다 : 스트림은 데이터 소스로부터 데이터를 읽기만할 뿐, 데이터 소스를 변경하지 않는다.
2. 스트림은 일회용이다 : 스트림도 Iterator처럼 한 번 사용하면 닫혀서 다시 사용할 수 없다.
3. 스트림은 작업을 내부 반복으로 처리한다 : 내부 반복이라는 것은 반복문을 메서드의 내부에 숨길 수 있다는 것을 의미한다.
4. 스트림의 연산 : 스트림이 제공하는 연산은 __중간 연산과 최종 연산__ 으로 분류할 수 있는데, 중간 연산은 연산 결과를 스트림으로 반환하기 때문에 `중간 연산을 연속해서 연결`할 수 있다. `최종 연산`은 스트림의 요소를 소모하면서 연산을 수행하므로 `단 한 번만 연산`이 가능하다.

```java
String[] strArr = {"dd", "aaa", "CC", "cc", "b"};
Stream<String> stream = Stream.of(strArr);
Stream<String> filteredStream = stream.filter();        //중간
Stream<String> distinctedStream = stream.distinct();    //중간
Stream<String> sortedStream = stream.sort();            //중간
Stream<String> limitedStream = stream.limit(5);         //중간
int total = Stream.count();                             //최종
```

<img src="/2회독/img/중간연산.jpeg" width="700px">

<img src="/2회독/img/최종연산.jpeg" width="700px">

중간 연산은 `map(), flatMap()`, 최종 연산은 `reduce(), collect()`가 핵심이다.

5. 지연된 연산 : 최종 연산이 수행되기 전까지는 중간 연산이 수행되지 않는다. 중간 연산을 호출하는 것은 단지 어떤 작업이 수행되어야 하는지를 지정해주는 것일 뿐이다. 최종 연산이 수행되어야 비로소 스트림의 요소들이 중간 연산을 거쳐 최종 연산에서 소모된다.
6. Stream\<Integer>와 IntStream : 기본형으로 다루는 스트림인 IntStream, LongStream, DoubleStream이 제공된다. 기본형인 경우엔 이 스트림을 사용하는 것이 더 효율적이다.
7. 병렬스트림 : 스트림을 병렬처리를 하려는 경우 parallel()이라는 메서드를 호출해서 병렬로 연산을 수행하도록 지시하면 된다. 반대인 경우 sequential()을 호출하면 된다.(기본적으로는 병렬스트림이 아님)

### 2.2 스트림 만들기
__컬렉션__

컬렉션의 최고 조상인 Collection에 stream()이 정의되어 있다. 그래서 Collection의 자손인 List, Set을 구현한 컬렉션 클래스들은 모두 이 메서드로 스트림을 생성할 수 있다. `Stream<T> Collection.stream()`
```java
List<Integer> list = Arrays.asList(1,2,3,4,5);
Stream<Integer> intStream = list.stream();

intStream.forEach(System.out::println);
intStream.forEach(System.out::println); //스트림이 이미 닫혀서 에러 발생
```

__배열__
```java
Stream<String> strStream = Stream.of("a", "b", "c", "d");
Stream<String> strStream = Stream.of(new String[]{"a", "b", "c", "d"});
Stream<String> strStream = Arrays.Stream(new String[]{"a", "b", "c", "d"});
Stream<String> strStream = Arrays.Stream(new String[]{"a", "b", "c", "d"}, 0, 3);
```

__특정 범위의 정수__
```java
IntStream intStream = IntStream.range(1,5); //1,2,3,4
IntStream intStream = IntStream.rangeClosed(1,5);   //1,2,3,4,5
```

__임의의 수__

난수를 생성하는데 사용하는 Random 클래스에는 다음과 같은 메서드들이 포함되어 있다. 이 메서드들이 반환하는 스트림은 크기가 정해져 있지 않은 '무한 스트림'이므로 limit()도 같이 사용해서 스트림의 크기를 제한해 주어야 한다.

```java
IntStream ints();
LongStream longs();
DoubleStream doubles();

IntStream intStream = new Random().ints();
intStream.limit(5).forEach(System.out::println);

IntStream intStream2 = new Random.ints(5);
```

__람다식 - iterator(), generate()__

Stream 클래스의 iterator()와 generate()는 람다식을 매개변수로 받아서, 계산되는 값들을 요소로 하는 무한 스트림을 생성한다.

__파일__
```
Stream<Path> Files.list(Path dir)
```

__빈 스트림__
```
//요소가 하나도 없는 비어있는 스트림
Stream emptyStream = Stream.empty();
```

__두 스트림의 연결__
```
Stream.concat(str1, str2);
```