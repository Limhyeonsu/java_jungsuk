# 14. 람다와 스트림
## 1. 람다식
JDK 1.8 부터 추가된 람다식으로 인해 자바는 객체지향 언어에서 동시에 함수형 언어가 되었다.

### 1.1 람다식이란?
람다식은 메서드를 하나의 __식(expression)__ 으로 표현한 것이다. 메서드를 람다식으로 표현하면 메서드의 이름과 반환 값이 없어지므로 람다식을 `익명함수` 라고도 한다.

```java
//람다식
int[] arr = new int[5];
Arrays.setAll(arr, () -> (int) (Math.random() * 5) +1);

//람다식 -> 메서드
int method() {
	return (int)(Math.random() * 5) + 1;
}
```

모든 메서드는 클래스에 포함되어야 하므로 클래스도 새로 만들어야 하고, 객체도 생성해야만 메서드를 호출할 수 있다. 그러나 람다식은 이 모든 과정 없이 오직 람다식 자체만으로 메서드 역할을 대신할 수 있다. 또 람다식은 메서드의 매개변수로 전달되어지는 것이 가능하고, 메서드의 결과로 반환될 수도 있다. 즉 메서드를 변수처럼 다루는 것이 가능해진 것이다.

**메서드와 함수의 차이 : 수학의 함수와 개념이 유사하나 객체지향 개념에서 함수 대신 객체의 행위나 동작을 의미하는 메서드라는 용어를 사용한다.

### 1.2 람다식 작성하기
메서드에서 이름과 반환 타입을 제거하고 매개변수 선언부와 몸통 사이에 '->' 를 추가한다. `(매개변수 선언) -> { 실행 문장들 }`

```java
int max(int a, int b) {
	return a > b ? a : b;
}

//1. 반환 타입과 메서드 이름을 제거한다.
(int a, int b) -> {
	return a > b ? a : b;
}

//2. 매개변수의 타입은 추론이 가능한 경우 생략할 수 있다.
// 그리고 문장이 아닌 식이므로 끝에 ; 을 붙이지 않는다.
(a, b) -> return a > b ? a : b

//3. 매개변수가 하나인 경우 () 괄호를 생략할 수 있다. 단 타입이 있는 경우 생략 불가
a -> a *a
(int a) -> a * a

//4. {} 괄호 안에 문장이 하나일땐 생략 가능, {} 괄호 안에 문장이 return 문인 경우 괄호 생략가능

```

<img src="/2회독/img/메서드to람다식.jpeg" width="700px">

### 1.3 함수형 인터페이스
람다식은 익명 클래스의 객체와 동등하다. 참조변수가 있어야 객체의 메서드를 호출할 수 있는 것처럼 익명 객체의 주소를 임의의 변수에 저장하기 위해서는 타입이 필요하다. 이때 타입은 어떤 타입으로 해야할까?

```java
interface MyFunction {
	public abstract int max(int a, int b);
}

MyFunction f = new MyFunction() {
	public int max(int a, int b) {
		return a > b ? a: b;
	}
};

int big = f.max(5, 3);  //익명 객체의 메서드 호출

MyFunction f = (int a, int b) -> a > b ? a : b; //람다식으로 대체

```
위 예제에서 MyFunction 인터페이스를 구현한 익명 객체를 람다식으로 대체 가능한 이유는 람다식도 실제로는 익명 객체이고, 익명 객체의 메서드 max()와 람다식의 매개변수의 타입과 개수, 반환값이 일치하기 때문이다. 그래서 인터페이스를 통해 람다식을 다루기로 결정되었으며 __람다식을 다루기 위한 인터페이스를 함수형 인터페이스__ 라고 부르기로 했다.

```java
@FunctionalInterface
interface MyFunction {
	public abstract int max(int a, int b);
}
```
`함수형 인터페이스`에는 오직 `하나의 추상 메서드만 정의`되어 있어야 한다는 제약이 있다. 그래야 람다식과 인터페이스의 메서드가 1:1로 연결될 수 있다. 반면 ststic 메서드와 default 메서드의 개수에는 제약이 없다.

```java

@FunctionalInterface
interface MyFunction {
	void myMethod();
}

//1. 함수형 인터페이스 타입의 매개변수인 경우 

void aMethod(MyFunction f) {
	f.myMethod();
}

...

MyFunction f = System.out.println("MyMethod()");
aMethod(f);		//참조 변수를 매개변수로 지정

aMethod(() -> System.out.println("myMethod"));  //람다식을 매개변수로 지정


//2. 함수형 인터페이스 타입의 반환 타입인 경우
MyFunction myMethod() {
	MyFunction f = () -> {};
	return f;  //참조 변수를 반환 타입으로 지정
	// return () -> {};  람다식을 직접 반환
}
```

__람다식의 타입과 형변환 :__ 람다식은 함수형 인터페이스로 람다식을 참조할 수 있을 뿐, 람다식의 타입이 함수형 인터페이스의 타입과 일치하는 것은 아니다. `람다식은 익명 객체이고, 익명 객체는 타입이 없다.`

__외부 변수를 참조하는 람다식__

```java
@FunctionalInterface
interface MyFunction {
	void myMethod();
}

class Outer {
	int val = 10;	//Outer.this.val

	class Inner {
		int val = 20;	//this.val

		void method(int i) {
			int val = 30;
			i = 10;  //error
			MyFunction f = () -> {
				System.out.println("i = " + i);
				System.out.println("val = " + val);
				System.out.println("this.val = " + ++this.val);
				System.out.println("Outer.this.val = " + ++Outer.this.val);
				System.out.println("i = " + i);
			}
		}
	}
}
```
위 예는 람다식 내에서 외부에 선언된 변수에 접근하는 방법이다. `람다식 내에서 참조하는 지역변수는 final이 붙지 않았어도 상수로 간주`된다. 따라서 __람다식 내에서 지역변수를 참조하고 있으므로 람다식 내에서나 다른 어느곳에서도 이 변수들의 값을 변경하는 일은 허용되지 않는다.__

### 1.4 java.util.function 패키지
대부분의 메서드는 타입이 비슷하다. 매개변수가 없거나 한 개 또는 두 개, 반환 값은 없거나 한 개, 게다가 지네릭 메서드로 정의하면 매개변수나 반환 타입이 달라도 문제가 되지 않는다. 그래서 java.util.function 패키지에 일반적으로 자주 쓰이는 형식의 메서드를 함수형 인터페이스로 미리 정의해 놓았다. 그래야 메서드의 이름도 통일되고, 재사용성이나 유지보수 측면에서도 좋다.

| 함수형 인터페이스          |메서드|설명|
|--------------------|----|---|
| java.lang.Runnable |void run()|매개변수도 없고, 반환값도 없음|
| Supplier\<T>       |T get()|매개변수는 없고, 반환값만 있음|
| Consumer\<T>       |void accept(T t)|Supplier와 반대로 매개변수만 있고, 반환값이 없음|
| Function\<T, R>    |R apply(T t)|하나의 매개변수를 받아서 결과를 반환|
| Predicate\<T>      |boolean test(T t)|조건식을 표현하는데 사용됨|

매개변수와 반환값의 유무에 따라 4개의 함수형 인터페이스가 정의되어 있고, Function의 변형으로 Predicate가 있다. 이는 조건식을 함수로 표현하는데 사용된다.

```java
Predicate<String> isEmptyStr = s -> s.length() == 0;
String s = "";
if(isEmptyStr.test(s)) System.out.println("This is an empty String");
```

매개변수가 두 개인 함수형 인터페이스

|함수형 인터페이스|메서드|설명|
|------------|----|---|
|BiConsumer\<T, U>| void accept(T t, U u)|두개의 매개변수만 있고 반환값이 없음|
|BiPredicate\<T,U>|boolean test(T t, U u)|조건식을 표현하는 데 사용됨, 매개변수는 둘 반환값은 boolean|
|BiFunction\<T,U,R>|R apply(T t, U u)|두 개의 매개변수를 받아서 하나의 결과를 반환|

UnaryOperator와 BinaryOperator는 Function의 또 다른 변형으로 매개변수의 타입과 반환타입의 타입이 모두 일치한다.

```java
//컬렉션 프레임웍과 함수형 인터페이스
ArrayList<Integer> list = new ArrayList<>();
for(int i = 0; i < 10; i++) {
    list.add(i);
}

list.forEach(i -> System.out.print(i+",");
list.removeIf(x -> x%2==0 || x%3==0);
list.replaceAll(i -> i*10)

Map<String, String> map = new HashMap<>();
map.put("1","1");
map.put("2","2");
map.put("3","3");
map.put("4","4");

map.forEach((k,v) -> System.out.println("{"+k + ", " + v + "}"); 
```

```java
//함수형 인터페이스 사용예제
Supplier<Integer> s = () -> (int)(Math.random()*100) +1;
Consumer<Integer> c = i -> System.out.println(i);
Predicate<Integer> p = i -> i%2==0;
Function<Integer, Integer> f = i -> i/10*10;
```

기본형을 사용하는 함수형 인터페이스

|함수형 인터페이스|메서드|설명|
|------------|----|---|
|DoubleToIntFunction|int applyAsInt(double d)|AtoBFunciotn은 입력이 A타입 출력이 B타입|
|ToIntFunction\<T>|int applyAsInt(T value)|ToBFunction은 출력이 B타입, 입력은 지네릭|
|ObjIntConsumer\<T>|void accept(T t, U u)| ObjAFunction은 입력이 T, A타입이고 출력은 없다|