# 15. 입출력 I/O
## 1. 자바에서의 입출력
### 1.1 입출력이란?
I/O는 입력과 출력을 나타낸다. 입출력은 컴퓨터 내부 또는 외부의 장치와 프로그램간의 데이터를 주고받는 것을 말한다. 

### 1.2 스트림(stream)
자바에서 입출력을 수행하려면 어느 한쪽에서 다른 쪽으로 데이터를 전달해야한다. 그러기 위해 두 대상을 연결하고 데이터를 전송할 수 있는 무언가가 필요한데 이것을 스트림이라고 정의했다. (입출력의 스트림과 Stream은 같은 용어이지만 다른 개념임)

`스트림이란 데이터를 운반하는데 사용되는 연결통로이다.` 스트림은 단방향통신만 가능하기 때문에 하나의 스트림으로 입력과 출력을 동시에 처리할 수 없다. 그래서 입출력을 동시에 수행하려면 입력을 위한 입력스트림, 출력을 위한 출력 스트림 2개가 모두 필요하다. 스트림은 먼저 보낸 데이터를 먼저 받게 되어 있으며 중간에 건너뜀 없이 연속적으로 데이터를 주고 받는다.(FIFO)

### 1.3 바이트기반 스트림 - InputStream, OutputStream
스트림은 바이트단위로 데이터를 전송한다.

* FileInputStream / FileOutputStream
* ByteArrayInputStream / ByteArrayOutputStream
* PipedInputStream / PipedOutputStream
* AudioInputStream / AudioOutputStream

java.io 패키지를 통해 많은 종류의 입출력관련 클래스들을 제공하고 있으며, 입출력을 처리할 수 있는 표준화된 방법을 제공함으로써 동일한 방법으로 입출력이 가능하여 편리하다.

|InputStream|OutputStream|
|----|----|
|abstract int read()|abstract void write(int b)|
|int read(byte[] b)|void write(byte[] b)|
|int read(byte[] b, int off, int len)|void write(byte[] b, int off, int len)|

### 1.4 보조 스트림
스트림을 보완하기 위한 기능을 제공하는 보조 스트림이 있다. 실제 데이터를 주고 받는 스트림이 아니기 때문에 데이터를 입출력할 수 있는 기능은 없지만, 스트림의 기능을 향상시키거나 새로운 기능을 추가할 수 있다. 그래서 보조 스트림만으로는 입출력을 처리할 수 없고, 스트림을 먼저 생성한 다음에 이를 이용해서 보조스트림을 생성해야 한다.

```java
//기반 스트림 생성
FileInputStream fis = new FileInputStream("test.txt");
//보조 스트림 생성
BufferedInputStream bis = new BufferedInputStream(fis);
//데이터 읽기
bis.read();
```
코드 상으로는 보조 스트림인 BufferedInputStream이 입력 기능을 수행하는 것처럼 보이지만, 실제 입력기능은 보조 스트림에 연결된 FileInputStream이 수행하고, 보조 스트림은 단순히 버퍼만 제공한다. 버퍼를 사용하느냐에 따라 성능차이가 상당하기 때문에 대부분의 경우 버퍼를 이용한 보조스트림을 사용한다. (보조 스트림도 결국 InputStream, OuputStream의 자손들이다.)

<img src="/2회독/img/보조스트림종류.jpeg" width="700px">

### 1.5 문자기반 스트림 - Reader, Writer
바이트 기반 스트림이라 함은 1byte 단위로 입출력을 한다는 것이다. 하지만 자바에서 char 는 2byte로 바이트 기반의 스트림으로는 문자를 처리하는데 어려움이 있다. 이점을 보완하기 위해 문자 기반의 스트림이 제공된다.
```
InputStream  -->  Reader
OutputStream -->  Writer
```
* FileReader / FileWriter
* CharArrayReader / CharArrayWriter
* PipedReader / PipedWriter
* StringReader / StringWriter

바이트 기반 스트림과 문자기반 스트림의 읽기 쓰기의 메서드 차이점은 매개변수로 byte[] -> char[] 로 바뀌었다는 것과 추상 메서드가 달라졌다. 그래도 이름만 조금 다를 뿐 활용 방법은 거의 같다. 보조스트림 역시 문자기반 보조스트림이 존재하며 사용 목적과 방식은 바이트기반 보조 스트림과 다르지 않다.

## 2. 바이트기반 스트림
### 2.1 InputStream 과 OutputStream
<img src="/2회독/img/stream 메서드.jpeg" width="700px">

스트림의 종류에 따라서 mark()와 reset()을 사용하여 이미 읽은 데이터를 되돌려서 다시 읽을 수 있다. flush()는 버퍼가 있는 출력 스트림의 경우에만 의미가 있고, OutputStream에 정의된 flush()는 아무런 일도 하지 않는다.

프로그램이 종료될 때, 사용하고 닫지 않은 스트림을 JVM이 자동으로 닫아 주기는 하지만 스트림을 사용해서 모든 작업을 마치고 난 후 close()를 호출해서 반드시 닫아 주어야 한다.

### 2.2 ByteArrayInputStream과 ByteArrayOutputStream
ByteArrayInputStream과 ByteArrayOutputStream는 메모리, 즉 바이트 배열에 데이터를 입출력 하는데 사용되는 스트림이다. 주로 다른데 입출력하기 전에 데이터를 임시로 바이트배열에 담아서 변환 등의 작업을 하는데 사용된다.

```java
class IOEx1 {
    public static void main(String[] args) {
        byte[] inSrc = {0,1,2,3,4,5,6,7,8,9};
        byte[] outSrc = null;
        
        ByteArrayInputStream input = null;      //기반 스트림
        ByteArrayOutputStream output = null;    //기반 스트림
        
        input = new ByteArrayInputStream(inSrc);
        output = new ByteArrayOutputStream();
        
        int data = 0;
        
        while((data = input.read()) != -1) {
            output.write(data);
        }
        
        outSrc = output.toByteArray();
        
        System.out.Println("Input Source : " + Arrays.toString(inSrc));
        System.out.Println("Output Source : " + Arrays.toString(outSrc));
    }
}
```

바이트배열은 사용하는 자원이 메모리 밖에 없으므로 가비지 컬렉터에 의해 자동적으로 자원을 반환하므로 close()를 이용해서 스트림을 닫지 않아도 된다. 그런데 read(), write()를 사용하기 때문에 한 번에 1byte만 읽고 쓰므로 작업 효율이 떨어진다.

```java
class IOEx2 {
    public static void main(String[] args) {
        byte[] inSrc = {0,1,2,3,4,5,6,7,8,9};
        byte[] outSrc = null;
        byte[] temp = new byte[10];
        
        ByteArrayInputStream input = null;      //기반 스트림
        ByteArrayOutputStream output = null;    //기반 스트림
        
        input = new ByteArrayInputStream(inSrc);
        output = new ByteArrayOutputStream();
        
        //byte 배열을 사용해서 한 번에 배열의 크기만큼 읽고 쓸 수 있다. (작업의 효율을 증가시킴)
        input.read(temp, 0, temp.length);
        output.write(temp, 5, 5);
        
        outSrc = output.toByteArray();
        
        System.out.Println("Input Source : " + Arrays.toString(inSrc));
        System.out.Println("temp         : " + Arrays.toString(temp));
        System.out.Println("Output Source : " + Arrays.toString(outSrc));
    }
}
```

### 2.3 FileInputStream과 FileOutputStream
```java
class FileViewer {
    public static void main(String[] args) throws IOException{
        FileInputStream fis = new FileInputStream(args[0]);
        int data = 0;
        
        while((data=file.read()) != -1) {
            char c = (char)data;
            System.out.println(c);
        }
    }
}
```
FileInputStream과 FileOutputStream을 사용해서 파일의 내용를 그대로 복사, 가져오기를 할 수 있다. 텍스트 파일을 다루는 경우 FileInputStream과 FileOutputStream 보다는 문자기반의 스트림인 FileReader, FileWriter를 사용하는 것이 더 좋다.

## 3. 바이트기반의 보조스트림
### 3.1 FilerInputStream 과 FilterOutputStream
FilerInputStream 과 FilterOutputStream은 InputStream/OutputStream의 자손이면서 모든 보조스트림의 조상이다. (보조스트림은 자체적으로 입출력을 수행할 수 없어 기반 스트림을 필요로 한다.) FilerInputStream의 경우 생성자의 접근 제어자가 protected이기 때문에 인스턴스를 생성해서 사용할 수 없고, 상속을 통해서 오버라이딩 되어야 한다.

### 3.2 BufferedInputStream과 BufferedOutputStream
스트림의 입출력 효율을 높이기 위해 버퍼를 사용하는 보조스트림으로 한 바이트씩 입출력 하는 것이 아닌 `버퍼(바이트 배열)를 이용해서 한 번에 여러 바이트를 입출력`하는 것이 빠르기 때문에 대부분의 입출력 작업에서 사용된다.

입력소스로부터 데이터를 읽기 위해 처음으로 read 메서드를 호출하면 BufferedInputStream은 입력소스로 부터 버퍼 크기만큼의 데이터를 읽어다 자신의 내부 버퍼에 저장한다. 그리고 프로그램은 버퍼에 저장된 데이터를 읽으면 된다. (훨씬 빠르다) 출력의 경우 버퍼가 가득 차면, 그때 버퍼의 모든 내용을 출력소스에 출력한다. 버퍼를 비우고 다시 출력을 저장할 준비를 하게 된다.

단, 버퍼가 가득 찼을 때만 출력소스에 출력을 하기 때문에 마지막 출력부분이 출력 소스에 쓰이지 못하고 BufferedOutputStream의 버퍼에 남아있는 채로 프로그램이 종료될 수 있다는 점을 주의하자 그래서 모든 출력 작업을 맞추면 close(), flush()를 사용해서 마지막에 버퍼에 남아있는 모든 내용이 출력소스에 출력되도록 해야 한다.

보조스트림을 사용하는 경우 기반 스트림의 close()나 flush()를 호출할 필요없이 단순히 보조스트림의 close()를 호출하기만 하면 된다.