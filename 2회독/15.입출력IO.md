# 15. 입출력 I/O
## 1. 자바에서의 입출력
### 1.1 입출력이란?
I/O는 입력과 출력을 나타낸다. 입출력은 컴퓨터 내부 또는 외부의 장치와 프로그램간의 데이터를 주고받는 것을 말한다. 

### 1.2 스트림(stream)
자바에서 입출력을 수행하려면 어느 한쪽에서 다른 쪽으로 데이터를 전달해야한다. 그러기 위해 두 대상을 연결하고 데이터를 전송할 수 있는 무언가가 필요한데 이것을 스트림이라고 정의했다. (입출력의 스트림과 Stream은 같은 용어이지만 다른 개념임)

`스트림이란 데이터를 운반하는데 사용되는 연결통로이다.` 스트림은 단방향통신만 가능하기 때문에 하나의 스트림으로 입력과 출력을 동시에 처리할 수 없다. 그래서 입출력을 동시에 수행하려면 입력을 위한 입력스트림, 출력을 위한 출력 스트림 2개가 모두 필요하다. 스트림은 먼저 보낸 데이터를 먼저 받게 되어 있으며 중간에 건너뜀 없이 연속적으로 데이터를 주고 받는다.(FIFO)

### 1.3 바이트기반 스트림 - InputStream, OutputStream
스트림은 바이트단위로 데이터를 전송한다.

* FileInputStream / FileOutputStream
* ByteArrayInputStream / ByteArrayOutputStream
* PipedInputStream / PipedOutputStream
* AudioInputStream / AudioOutputStream

java.io 패키지를 통해 많은 종류의 입출력관련 클래스들을 제공하고 있으며, 입출력을 처리할 수 있는 표준화된 방법을 제공함으로써 동일한 방법으로 입출력이 가능하여 편리하다.

|InputStream|OutputStream|
|----|----|
|abstract int read()|abstract void write(int b)|
|int read(byte[] b)|void write(byte[] b)|
|int read(byte[] b, int off, int len)|void write(byte[] b, int off, int len)|

### 1.4 보조 스트림
스트림을 보완하기 위한 기능을 제공하는 보조 스트림이 있다. 실제 데이터를 주고 받는 스트림이 아니기 때문에 데이터를 입출력할 수 있는 기능은 없지만, 스트림의 기능을 향상시키거나 새로운 기능을 추가할 수 있다. 그래서 보조 스트림만으로는 입출력을 처리할 수 없고, 스트림을 먼저 생성한 다음에 이를 이용해서 보조스트림을 생성해야 한다.

```java
//기반 스트림 생성
FileInputStream fis = new FileInputStream("test.txt");
//보조 스트림 생성
BufferedInputStream bis = new BufferedInputStream(fis);
//데이터 읽기
bis.read();
```
코드 상으로는 보조 스트림인 BufferedInputStream이 입력 기능을 수행하는 것처럼 보이지만, 실제 입력기능은 보조 스트림에 연결된 FileInputStream이 수행하고, 보조 스트림은 단순히 버퍼만 제공한다. 버퍼를 사용하느냐에 따라 성능차이가 상당하기 때문에 대부분의 경우 버퍼를 이용한 보조스트림을 사용한다. (보조 스트림도 결국 InputStream, OuputStream의 자손들이다.)

<img src="/2회독/img/보조스트림종류.jpeg" width="700px">

### 1.5 문자기반 스트림 - Reader, Writer
바이트 기반 스트림이라 함은 1byte 단위로 입출력을 한다는 것이다. 하지만 자바에서 char 는 2byte로 바이트 기반의 스트림으로는 문자를 처리하는데 어려움이 있다. 이점을 보완하기 위해 문자 기반의 스트림이 제공된다.
```
InputStream  -->  Reader
OutputStream -->  Writer
```
* FileReader / FileWriter
* CharArrayReader / CharArrayWriter
* PipedReader / PipedWriter
* StringReader / StringWriter

바이트 기반 스트림과 문자기반 스트림의 읽기 쓰기의 메서드 차이점은 매개변수로 byte[] -> char[] 로 바뀌었다는 것과 추상 메서드가 달라졌다. 그래도 이름만 조금 다를 뿐 활용 방법은 거의 같다. 보조스트림 역시 문자기반 보조스트림이 존재하며 사용 목적과 방식은 바이트기반 보조 스트림과 다르지 않다.

## 2. 바이트기반 스트림
### 2.1 InputStream 과 OutputStream
<img src="/2회독/img/stream 메서드.jpeg" width="700px">

스트림의 종류에 따라서 mark()와 reset()을 사용하여 이미 읽은 데이터를 되돌려서 다시 읽을 수 있다. flush()는 버퍼가 있는 출력 스트림의 경우에만 의미가 있고, OutputStream에 정의된 flush()는 아무런 일도 하지 않는다.

프로그램이 종료될 때, 사용하고 닫지 않은 스트림을 JVM이 자동으로 닫아 주기는 하지만 스트림을 사용해서 모든 작업을 마치고 난 후 close()를 호출해서 반드시 닫아 주어야 한다.

### 2.2 ByteArrayInputStream과 ByteArrayOutputStream
ByteArrayInputStream과 ByteArrayOutputStream는 메모리, 즉 바이트 배열에 데이터를 입출력 하는데 사용되는 스트림이다. 주로 다른데 입출력하기 전에 데이터를 임시로 바이트배열에 담아서 변환 등의 작업을 하는데 사용된다.

```java
class IOEx1 {
    public static void main(String[] args) {
        byte[] inSrc = {0,1,2,3,4,5,6,7,8,9};
        byte[] outSrc = null;
        
        ByteArrayInputStream input = null;      //기반 스트림
        ByteArrayOutputStream output = null;    //기반 스트림
        
        input = new ByteArrayInputStream(inSrc);
        output = new ByteArrayOutputStream();
        
        int data = 0;
        
        while((data = input.read()) != -1) {
            output.write(data);
        }
        
        outSrc = output.toByteArray();
        
        System.out.Println("Input Source : " + Arrays.toString(inSrc));
        System.out.Println("Output Source : " + Arrays.toString(outSrc));
    }
}
```

바이트배열은 사용하는 자원이 메모리 밖에 없으므로 가비지 컬렉터에 의해 자동적으로 자원을 반환하므로 close()를 이용해서 스트림을 닫지 않아도 된다. 그런데 read(), write()를 사용하기 때문에 한 번에 1byte만 읽고 쓰므로 작업 효율이 떨어진다.

```java
class IOEx2 {
    public static void main(String[] args) {
        byte[] inSrc = {0,1,2,3,4,5,6,7,8,9};
        byte[] outSrc = null;
        byte[] temp = new byte[10];
        
        ByteArrayInputStream input = null;      //기반 스트림
        ByteArrayOutputStream output = null;    //기반 스트림
        
        input = new ByteArrayInputStream(inSrc);
        output = new ByteArrayOutputStream();
        
        //byte 배열을 사용해서 한 번에 배열의 크기만큼 읽고 쓸 수 있다. (작업의 효율을 증가시킴)
        input.read(temp, 0, temp.length);
        output.write(temp, 5, 5);
        
        outSrc = output.toByteArray();
        
        System.out.Println("Input Source : " + Arrays.toString(inSrc));
        System.out.Println("temp         : " + Arrays.toString(temp));
        System.out.Println("Output Source : " + Arrays.toString(outSrc));
    }
}
```

### 2.3 FileInputStream과 FileOutputStream
```java
class FileViewer {
    public static void main(String[] args) throws IOException{
        FileInputStream fis = new FileInputStream(args[0]);
        int data = 0;
        
        while((data=file.read()) != -1) {
            char c = (char)data;
            System.out.println(c);
        }
    }
}
```
FileInputStream과 FileOutputStream을 사용해서 파일의 내용를 그대로 복사, 가져오기를 할 수 있다. 텍스트 파일을 다루는 경우 FileInputStream과 FileOutputStream 보다는 문자기반의 스트림인 FileReader, FileWriter를 사용하는 것이 더 좋다.

## 3. 바이트기반의 보조스트림
### 3.1 FilerInputStream 과 FilterOutputStream
FilerInputStream 과 FilterOutputStream은 InputStream/OutputStream의 자손이면서 모든 보조스트림의 조상이다. (보조스트림은 자체적으로 입출력을 수행할 수 없어 기반 스트림을 필요로 한다.) FilerInputStream의 경우 생성자의 접근 제어자가 protected이기 때문에 인스턴스를 생성해서 사용할 수 없고, 상속을 통해서 오버라이딩 되어야 한다.

### 3.2 BufferedInputStream과 BufferedOutputStream
스트림의 입출력 효율을 높이기 위해 버퍼를 사용하는 보조스트림으로 한 바이트씩 입출력 하는 것이 아닌 `버퍼(바이트 배열)를 이용해서 한 번에 여러 바이트를 입출력`하는 것이 빠르기 때문에 대부분의 입출력 작업에서 사용된다.

입력소스로부터 데이터를 읽기 위해 처음으로 read 메서드를 호출하면 BufferedInputStream은 입력소스로 부터 버퍼 크기만큼의 데이터를 읽어다 자신의 내부 버퍼에 저장한다. 그리고 프로그램은 버퍼에 저장된 데이터를 읽으면 된다. (훨씬 빠르다) 출력의 경우 버퍼가 가득 차면, 그때 버퍼의 모든 내용을 출력소스에 출력한다. 버퍼를 비우고 다시 출력을 저장할 준비를 하게 된다.

단, 버퍼가 가득 찼을 때만 출력소스에 출력을 하기 때문에 마지막 출력부분이 출력 소스에 쓰이지 못하고 BufferedOutputStream의 버퍼에 남아있는 채로 프로그램이 종료될 수 있다는 점을 주의하자 그래서 모든 출력 작업을 맞추면 close(), flush()를 사용해서 마지막에 버퍼에 남아있는 모든 내용이 출력소스에 출력되도록 해야 한다.

보조스트림을 사용하는 경우 기반 스트림의 close()나 flush()를 호출할 필요없이 단순히 보조스트림의 close()를 호출하기만 하면 된다.

### 3.3 DataInputStream과 DataOutputStream
DataInputStream과 DataOutputStream도 각각 FileInputStream, FileOutputStream의 자손이고 각각 DataInput, DataOutput 인터페이스를 구현하였기 때문에 데이터를 읽고 쓰는데 있어서 byte 단위가 아닌 8가지 기본 자료형의 단위로 읽고 쓸 수 있다는 장점이 있다. 

DataOutputStream이 출력하는 형식은 각 기본 자료형 값을 16진수로 표현하여 저장한다. 데이터를 읽어올땐 각 타입에 맞게 값을 읽고 더 이상 읽을 값이 없으면 EOFException을 발생시킨다.

```java
FileOutputStream fos = null;
DataOutputStream dos = null;

try {
    fos = new FileOutputStream("sample.dat");
    dos = new DataOutputSream(fos);
    
    dos.writeInt(10);       //sample.dat 파일에 값 출력
    dos.writeFloat(20.0f);
    dos.writeBoolean(true);
    
    dos.close();        //보조스트림 닫기
}catch(IOException e) {
    e.printStackTrace();
}
```

그리고 ByteArrayInputStream, ByteArrayOuputStream을 사용하면 byte 단위의 데이터 변환 및 조작이 가능하다. 

참고) 자바의 자료형인 byte의 범위는 부호 있는 1byte 정수의 범위인 -128~127이기 때문에 -1로 인식한다. 이 값을 0~255 사이의 값으로 변환하려면 256을 더해주어야 한다. 반대의 경우에는 256을 빼주면 된다.

DataOutputStream에 의해 기록된 데이터는 DataInputStream의 read 메서드들로 읽기만 하면 되는데 이 때 주의할 것은 반드시 쓰인 순서대로 읽어야 한다.

```java
try {
    FileInputStream fis = new FileInputStream("sample.dat");
    DataInputStream dis = new DataInputStream(fis);
    
    //데이터의 자료형을 쓰인 순서대로 읽어온다.
    System.out.println(dis.readInt());
    System.out.println(dis.readFloat());
    System.out.println(dis.readBoolean());
    
    dis.close()l
} catch(IOException e) {
    e.printStackTrace();
}
```

JDK1.7부터는 try-with-resource문을 이용해서 close()를 직접 호출하지 않아도 자동호출되도록 할 수 있다.
```java
int sum = 0
int score = 0;

try (FileInputStream fis = new FileInputStream("score.dat");
     DataInputStream dis = new DataInputStream(fis)){
     while(true) {
        score = dis.readInt();
        System.out.println(score);
        sum += score;
     }

} catch(EOFException e) {
    System.out.println("점수의 총합은 " + sum + "입니다.");
} catch(IOException ie) {
    ie.printStackTrace();
}
```

### 3.4 SequenceInputStream
여러 개의 입력스트림을 연속적으로 연결해서 하나의 스트림으로부터 데이터를 읽는 것과 같이 처리할 수 있도록 도와준다.
```
FileInputStream file1 = new FileInputStream("file.001");
FileInputStream file2 = new FileInputStream("file.002");
SequenceInputStream in = new SequenceInputStream(file1, file2);
```

### 3.5 PrintStream
PrintStream은 데이터를 기반스트림에 다양한 형태로 출력할 수 있는 print, println, printf와 같은 메서드를 오버로딩하여 제공한다.

PrintStream 보다 향상된 기능의 문자기반 스트림인 PrintWriter가 추가되었다. 거의 같은 기능을 가지고 있지만 PrintStream에 비해 다양한 언어의 문자를 처리하는데 적합하기 때문에 가능하면 PrintWriter를 사용하는 것이 좋다.

print(), println()을 이용해서 출력하는 중에 PrintStream의 기반스트림에서 IOException이 발생하면 checkError()를 통해서 인지할 수 있다. println()과 같은 메서드가 매우 자주 사용되기 때문에 예외를 던지도록 정의했다면 사용하는 모든곳에 try~catch문을 사용해야 했을 것이다.

```
Date d = new Date();
System.out.printf("오늘은 %tY년 %tm월 %td일 입니다. %n", d, d, d);
System.out.printf("지금은 %tH시 %tM분 %tds초 입니다. %n", d, d, d);

//숫자$를 옵션 앞에 붙여 줌으로써 출련된 매개변수를 지정해 줄 수 있다.
System.out.printf("지금은 %1$tH시 %1$tM분 %1$tds초 입니다. %n", d);
```

## 4. 문자기반 스트림
문자 데이터를 다루는데 사용된다는 것을 제외하고는 바이트기반 스트림과 문자기반 스트림의 사용방법은 거의 같다.

### 4.1 Reader와 Writer
문자 기반 스트림에서는 Reader와 Writer가 문자 스트림의 조상이다. 메서드에서 byte 배열대신 char 배열을 사용한다는 것 외에는 InputStream/OutputStream의 메서드와 다르지 않다.

문자 데이터를 다루는데 필요한 또 하나의 정보는 인코딩이다. 문자기반 스트림에서는 여러 종류의 인코딩과 자바에서 사용하는 유니코드(UTF-16)간의 변환을 자동적으로 처리해준다. Reader는 특정 인코딩을 읽어서 유니코드로 변환하고 Writer는 유니코드를 특정 인코딩으로 변환하여 저장한다.

### 4.2 FileReader와 FileWriter
```java
try {
    String fileName = "test.txt";
    FileInputStream fis = new FileInputStream(fileName);
    FileReader fr = new FileReader(fileName);
    
    int data = 0;
    
    //FileInputStream을 이용해서 출력
    while((data = fis.read()) != -1) {
        System.out.print((char)data);   //한글이 깨져서 출력됨
    }
    System.out.println();
    fis.close();
    
    //FileReader를 이용해서 출력
    while((data = fr.read()) != -1){
        System.out.print((char)data);   //한글이 정상적으로 출력됨
    }
    System.out.println();
    fr.close();
    
}catch(IOException e) {
    e.printStackTrace();
}
```

### 4.3 PipedReader와 PipedWriter
쓰레드간에 데이터를 주고 받을 때 사용된다. 다른 스트림과 달리 입력과 출력스트림을 하나의 스트림으로 연결해서 데이터를 주고 받는다는 특징이 있다.

스트림을 생성한 다음에 어느 한쪽 스레드에서 connect()를 호출해서 입력스트림과 출력스트림을 연결한다.

```java
public class PipeReaderWriter {
    public static void main(String[] args) {
        InputThread inThread = new InputThread("InputThread");
        OutputThread outThread = new OutputThread("OutputThread");
        
        //PipeReader와 PipeWriter를 연결한다.
        inThread.connect(outThread.getOutput());
        
        inThread.start();
        outThread.start();
    }
}

class InputThread extends Thread {
    PipedReader input = new PipedReader();
    StringWriter sw = new StringWriter();
    
    InputThread(String name) {
        super(name);
    }
    
    public void run() {
        try {
            int data = 0;
            
            while((data=input.read()) != -1) sw.write(data);
            
            System.out.println(getName() + " received : " + sw.toString());
        }catch(IOException e) {}
    }
    
    public PipedReader getInput() {
        return input;
    }
    
    public void connect(PipedWriter output) {
        try{
            input.connect(output);
        }catch(IOException e) {}
    }
}

class OutputThread extends Thread {
    PipedWriter output = new PipedWriter();
    
    OutputThread(String name) {
        super(name);
    }
    
    public void run() {
        try {
            String msg = "Hello";
            System.out.println(getName() + " sent : " + msg);
            
            output.write(msg);
            output.close();
        }catch(IOException e) {}
    }
    
    public PipedReader getOutput() {
        return output;
    }
    
    public void connect(PipedReader input) {
        try{
            output.connect(input);
        }catch(IOException e) {}
    }
    
}
```

__쓰레드가 시작하기 전에 PipedReader와 PipedWriter를 연결해야 한다__